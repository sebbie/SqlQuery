<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ Assembly Name="System.Data" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data.SqlClient" #> 
<#@ import namespace="System.Text.RegularExpressions" #>
<#+
	void render(SqlQuery sqlQuery)
	{
		sqlQuery.ReadDatabase();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Last generated on <#= DateTime.Now #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Threading.Tasks;

namespace <#= sqlQuery.Namespace #>
{
	public static class Sql
	{
		private static string connectionString = "<#= sqlQuery.ConnectionString #>";
		private static SqlExecuteConnectionManagerDefault sqlConnectionManager = null;
		private static ISqlExecute sqlExecute = null;
		private static IDbRepository dbRepo = null;

		public static string ConnectionString
		{
			get { return connectionString; }
			set { connectionString = value; }
		}
		public static IDbRepository DbRepository
		{
			get
			{
				if( dbRepo == null || sqlConnectionManager.ConnectionString != ConnectionString)
				{
					sqlConnectionManager = new SqlExecuteConnectionManagerDefault(ConnectionString);
					sqlExecute = new SqlExecute(sqlConnectionManager);
					dbRepo = new DbRepository(sqlExecute);
				}
				return dbRepo;
			}
		}
	}
	public class SqlExecuteConnectionManagerDefault : SqlExecuteConnectionManager
	{
		public string ConnectionString { get; set; }

		public SqlExecuteConnectionManagerDefault(string connectionString)
		{
			ConnectionString = connectionString;
		}
		public override string GetConnectionString()
		{
			return ConnectionString;
		}
	}
	public partial interface ISqlExecute
	{
		Task ExecuteSql(string sql, List<SqlExecuteParameter> parameters, Action<SqlExecutePopulateRowCtx> populateRow);
	}
	public interface ISqlExecuteConnectionManager
	{
		string GetConnectionString();
		SqlConnection GetSqlConnection();
	}
	public abstract class SqlExecuteConnectionManager : ISqlExecuteConnectionManager
	{
		public abstract string GetConnectionString();

		public virtual SqlConnection GetSqlConnection()
		{
			return new SqlConnection(GetConnectionString());
		}
	}
	public class SqlExecuteParameter
	{
		public string ParameterName { get; set; }
		public object ParameterValue { get; set; }
		public SqlExecuteParameter(string parameterName, object parameterValue)
		{
			ParameterName = parameterName;
			ParameterValue = parameterValue;
		}
	}
	public class SqlExecutePopulateRowCtx
	{
		private SqlDataReader SqlDataReader { get; set; }
		public int ResultSetIx { get; set; }

		public SqlExecutePopulateRowCtx(SqlDataReader sqlDataReader)
		{
			SqlDataReader = sqlDataReader;
		}

		public int? GetInt32(int ix) => SqlDataReader.IsDBNull(ix) ? (int?)null : SqlDataReader.GetInt32(ix);
		public int GetInt32(int ix, int defVal = 0) => GetInt32(ix) ?? defVal;
		
		public string GetString(int ix, string defVal = null) => SqlDataReader.IsDBNull(ix) ? defVal : SqlDataReader.GetString(ix);

		public decimal? GetDecimal(int ix) => SqlDataReader.IsDBNull(ix) ? (decimal?)null : SqlDataReader.GetDecimal(ix);
		public decimal GetDecimal(int ix, decimal defVal = 0) => GetDecimal(ix) ?? defVal;

		public double? GetDouble(int ix) => SqlDataReader.IsDBNull(ix) ? (double?)null : SqlDataReader.GetDouble(ix);
		public double GetDouble(int ix, double defVal = 0) => GetDouble(ix) ?? defVal;

		public bool? GetBool(int ix) => SqlDataReader.IsDBNull(ix) ? (bool?)null : SqlDataReader.GetBoolean(ix);
		public bool GetBool(int ix, bool defVal = false) => GetBool(ix) ?? defVal;
	}
	public class SqlExecute : ISqlExecute
	{
		public ISqlExecuteConnectionManager SqlExecuteConnectionManager { get; set; }
		public SqlExecute(ISqlExecuteConnectionManager sqlExecuteConnectionManager)
		{
			SqlExecuteConnectionManager = sqlExecuteConnectionManager;
		}

		public async Task ExecuteSql(string sql, List<SqlExecuteParameter> parameters, Action<SqlExecutePopulateRowCtx> populateRow)
		{
			SqlTransaction sqlTransaction = null;

			try
			{
				using (var sqlConnection = SqlExecuteConnectionManager.GetSqlConnection())
				{
					sqlConnection.Open();
					sqlTransaction = sqlConnection.BeginTransaction();

					var sqlCmd = new SqlCommand(sql, sqlConnection, sqlTransaction);
					foreach (var parameter in parameters)
					{
						var sqlParam = new SqlParameter(parameter.ParameterName, parameter.ParameterValue);
						if (parameter.ParameterValue is DataTable)
						{
							sqlParam.TypeName = ((DataTable)parameter.ParameterValue).TableName;
							sqlParam.SqlDbType = SqlDbType.Structured;
						}

						sqlCmd.Parameters.Add(sqlParam);
					}

					var sqlDataReaderAsync = sqlCmd.ExecuteReaderAsync();
					await sqlDataReaderAsync;
					if (sqlDataReaderAsync.IsFaulted)
						throw sqlDataReaderAsync.Exception;

					// reader ready
					var sqlDataReader = sqlDataReaderAsync.Result;
					SqlExecutePopulateRowCtx populateRowCtx = new SqlExecutePopulateRowCtx(sqlDataReader);
					bool readNextResultSet = false;
					do
					{
						while (true)
						{
							var readAsync = sqlDataReader.ReadAsync();
							await readAsync;
							if (readAsync.IsFaulted)
								throw readAsync.Exception;

							if (!readAsync.Result)
								break;

							populateRow(populateRowCtx);
						}

						// advance to next result set
						var nextResultAsync = sqlDataReader.NextResultAsync();
						await nextResultAsync;
						if (nextResultAsync.IsFaulted)
							throw nextResultAsync.Exception;
						readNextResultSet = nextResultAsync.Result;

						populateRowCtx.ResultSetIx++;

					} while (readNextResultSet);
					sqlDataReader.Close();
					if (sqlTransaction != null)
						sqlTransaction.Commit();
					sqlTransaction = null;
				}

			}
			catch
			{
				throw;
			}
			finally
			{
				try
				{
					if (sqlTransaction != null)
						sqlTransaction.Rollback();
				}
				catch { }
			}
		}
	}
<#+
		// utility class
		foreach(var sqlProc in sqlQuery.SqlProcs)
		{
#>
	public static class <#= sqlProc.CSharpNameUtilsClass #>
	{
		private const string storedProcedureName = "<#= sqlProc.SqlCallProc #>";

		public static async Task<<#= sqlProc.CSharpResultClassName #>> Query(ISqlExecute sqlExecute<#= sqlProc.Parameters.Any() ? ", " : "" #><#= sqlProc.CSharpParametersList #>)
		{
			var parameters = new List<SqlExecuteParameter>
			{
<#+
		foreach(SqlProcParameter param in sqlProc.Parameters)
		{
#>				new SqlExecuteParameter("<#= param.ParameterName #>", <#= param.IsTvp ? (param.CSharpType + ".ToDataTable(" + param.ParameterName + ")") : param.ParameterName #>),
<#+
		}
#>
			};

<#+
		int paramIx = 0;
		foreach(SqlProcResultSet resultSet in sqlProc.SqlProcResultSets)
		{
#>		List<<#= sqlProc.CSharpResultClassName #>.<#= resultSet.CSharpClassName #>> result<#= paramIx++ #> = new List<<#= sqlProc.CSharpResultClassName #>.<#= resultSet.CSharpClassName #>>();
<#+
		}
#>

			var executeSqlStatus = sqlExecute.ExecuteSql(storedProcedureName, parameters, sqlExecutePopulateRowCtx =>
			{
<#+
				if(sqlProc.SqlProcResultSets.Any())
				{
#>
				switch (sqlExecutePopulateRowCtx.ResultSetIx)
				{
<#+
		for(int i = 0; i < sqlProc.SqlProcResultSets.Count; i++)
		{
#>
					case <#= i #>: result<#= i #>.Add(Populate<#= i #>(CreateNew<#= i #>(), sqlExecutePopulateRowCtx)); break;
<#+
		}
#>
				}
<#+
				}
#>
			});
			await executeSqlStatus;
			if (executeSqlStatus.IsFaulted)
				throw executeSqlStatus.Exception;
			return new <#= sqlProc.CSharpResultClassName #>
			{
<#+
		for(int i = 0; i < sqlProc.SqlProcResultSets.Count; i++)
		{
#>				<#= sqlProc.SqlProcResultSets[i].CSharpCollectionName #> = result<#= i #>,
<#+		}
#>
			};
		}
<#+
		for(int i = 0; i < sqlProc.SqlProcResultSets.Count; i++)
		{
			var resultSet = sqlProc.SqlProcResultSets[i];
#>
		public static <#= sqlProc.CSharpResultClassName #>.<#= resultSet.CSharpClassName #> CreateNew<#= i #>() => new <#= sqlProc.CSharpResultClassName #>.<#= resultSet.CSharpClassName #>();
<#+		}

		for(int i = 0; i < sqlProc.SqlProcResultSets.Count; i++)
		{
			var resultSet = sqlProc.SqlProcResultSets[i];
#>

		public static <#= sqlProc.CSharpResultClassName #>.<#= resultSet.CSharpClassName #> Populate<#= i #>(<#= sqlProc.CSharpResultClassName #>.<#= resultSet.CSharpClassName #> dst, SqlExecutePopulateRowCtx src)
		{
<#+
			for(int colIx = 0; colIx < resultSet.Columns.Count; colIx++)
			{
				SqlProcColumn column = resultSet.Columns[colIx];
#>
			dst.<#= column.CSharpName #> = src.<#= column.CSharpReaderGetterMethod(colIx) #>;
<#+
			}
#>
			return dst;
		}
<#+
		}
#>
	}
<#+
		}
#>

<#+
	var tvpParameters = sqlQuery.SqlProcs.SelectMany(proc => proc.Parameters.Where(prm => prm.IsTvp)).ToList();
	List<string> alreadyGenerated = new List<string>();
	foreach(SqlProcParameter sqlProcParam in tvpParameters)
	{
		if(alreadyGenerated.Contains(sqlProcParam.ParameterType))
			continue;
		alreadyGenerated.Add(sqlProcParam.ParameterType);
#>
	public partial class <#= sqlProcParam.CSharpType #>
	{
		public static string DbName { get; set; } = "<#= sqlProcParam.ParameterType #>";

<#+		foreach(SqlProcColumn column in sqlProcParam.TvpColumns)
		{
#>		public <#= column.CSharpType #> <#= column.CSharpName #> { get; set; }
<#+		}
#>

		public <#= sqlProcParam.CSharpType #>(<#= sqlProcParam.CSharpParametersList #>)
		{
<#+		foreach(SqlProcColumn column in sqlProcParam.TvpColumns)
		{
#>			this.<#= column.CSharpName #> = <#= column.CSharpNameLowercase #>;
<#+		}
#>		}

		public static DataTable ToDataTable(List<<#= sqlProcParam.CSharpType #>> src)
		{
			DataTable dst = new DataTable(DbName);
<#+		foreach(SqlProcColumn column in sqlProcParam.TvpColumns)
		{
#>			dst.Columns.Add("<#= column.ColumnName #>", typeof(<#= column.CSharpTypeForDataSet #>));
<#+		}
#>
			foreach (<#= sqlProcParam.CSharpType #> s in src)
				dst.Rows.Add(<#= string.Join(", ", sqlProcParam.TvpColumns.Select(column => "s." + column.CSharpName)) #>);
			return dst;
		}
	}
<#+
	}

	foreach(var sqlProc in sqlQuery.SqlProcs)
	{
#>
	public partial class <#= sqlProc.CSharpResultClassName #>
	{
<#+
		foreach(SqlProcResultSet resultSet in sqlProc.SqlProcResultSets)
		{
#>
		public partial class <#= resultSet.CSharpClassName #>
		{
<#+
			foreach(SqlProcColumn column in resultSet.Columns)
			{
#>
			public <#= column.CSharpType #> <#= column.CSharpName #> { get; set; }
<#+
			}
#>		}
<#+
		}
		foreach(SqlProcResultSet resultSet in sqlProc.SqlProcResultSets)
		{
#>		public List<<#= resultSet.CSharpClassName #>> <#= resultSet.CSharpCollectionName #> { get; set; }
<#+
		}
#>
	}
<#+	} #>
	public partial interface IDbRepository
	{
<#+		foreach(var sqlProc in sqlQuery.SqlProcs)
		{
#>
		<#= sqlProc.CSharpResultClassName #> <#= sqlProc.CSharpRepositoryMethodName #>(<#= sqlProc.CSharpParametersList #>);
		Task<<#= sqlProc.CSharpResultClassName #>> <#= sqlProc.CSharpRepositoryAsyncMethodName #>(<#= sqlProc.CSharpParametersList #>);

<#+
		}
#>
	}
	public class DbRepository : IDbRepository
	{
		public ISqlExecute _sqlExecute;
		public DbRepository(ISqlExecute sqlExecute)
		{
			_sqlExecute = sqlExecute;
		}

<#+		foreach(var sqlProc in sqlQuery.SqlProcs)
		{
#>
			public <#= sqlProc.CSharpResultClassName #> <#= sqlProc.CSharpRepositoryMethodName #>(<#= sqlProc.CSharpParametersList #>) =>
			<#= sqlProc.CSharpNameUtilsClass #>.Query(_sqlExecute<#= sqlProc.Parameters.Any() ? ", " : "" #><#= sqlProc.CSharpParametersCallMethod #>).Result;
			public Task<<#= sqlProc.CSharpResultClassName #>> <#= sqlProc.CSharpRepositoryAsyncMethodName #>(<#= sqlProc.CSharpParametersList #>) =>
			<#= sqlProc.CSharpNameUtilsClass #>.Query(_sqlExecute<#= sqlProc.Parameters.Any() ? ", " : "" #><#= sqlProc.CSharpParametersCallMethod #>);

<#+		}
#>
	}
}
<#+
		}
#>

<#+
	public class SqlQuery
	{
		public string ConnectionString {get; set;}
		public List<SqlProc> SqlProcs {get; set;}
		public string Namespace { get; set; }

		public SqlQuery()
		{
			SqlProcs = new List<SqlProc>();
		}

		public SqlQuery(string connectionString, string @namespace)
			: this()
		{
			ConnectionString = connectionString;
			Namespace = @namespace;
		}

		public SqlQuery Add(SqlProc sqlProc)
		{
			SqlProcs.Add(sqlProc);
			return this;
		}

		public SqlQuery ReadDatabase()
		{
			foreach(var sqlProc in SqlProcs)
			{
				// read proc details
				ExecuteQuery("SELECT p.name ProcName, s.name SchemaName, p.object_id ProcObjectId FROM sys.procedures p join sys.schemas s on s.schema_id = p.schema_id WHERE s.name + '.' + p.name = '" + sqlProc.ProcName +  "'", row =>
					{
						sqlProc.ObjectId = row.GetInt32(2);
					});
				// read parameters list
				sqlProc.Parameters = new List<SqlProcParameter>();
				ExecuteQuery("select pa.name ParamName, pa.parameter_id ParameterOrder, ty.name ParamType, CAST(CASE WHEN ty.system_type_id <> ty.user_type_id THEN 1 ELSE 0 END AS BIT) IsTvp from sys.parameters pa join sys.types ty on ty.user_type_id = pa.user_type_id and ty.system_type_id = pa.system_type_id where object_id = " + sqlProc.ObjectId + " order by parameter_id", row =>
					{
						sqlProc.Parameters.Add(new SqlProcParameter(row.GetString(0).Substring(1), row.GetString(2), row.GetBoolean(3)));
					});
				// read tvp definitions
				foreach(var param in sqlProc.Parameters.Where(p => p.IsTvp))
				{
					// tvp object id
					ExecuteQuery("select tt.type_table_object_id from sys.table_types tt where tt.name = '" + param.ParameterType + "'", row =>
						{
							param.TvpObjectId = row.GetInt32(0);
						});
					// tvp columns
					param.TvpColumns = new List<SqlProcColumn>();
					ExecuteQuery("select c.name TvpColumnName, c.column_id ColumnIx, ty.name TypeName, c.is_nullable IsNullable from sys.columns c join sys.types ty on ty.user_type_id = c.user_type_id and ty.system_type_id = c.system_type_id where c.object_id = " + param.TvpObjectId, row =>
						{
							param.TvpColumns.Add(new SqlProcColumn(
								row.GetString(0),
								row.GetInt32(1),
								row.GetString(2),
								row.GetBoolean(3)));
						});
				}
				// result sets
				var nonTvpParams = sqlProc.Parameters.Where(p => !p.IsTvp).ToList();
				int numberOfResultSetsRetrieved = 0;
				InspectResultSets("EXEC " + sqlProc.ProcName + " " +
					string.Join(", ", nonTvpParams.Select(p => "@" + p.ParameterName + "=" + (sqlProc.GetParameterValue(p.ParameterName) ?? SqlDataTypesHelper.GetDefaultSqlValue(p.ParameterType)))), (resultSetIx, row) =>
					{
						if( resultSetIx > numberOfResultSetsRetrieved)
							numberOfResultSetsRetrieved = resultSetIx;
						SqlProcResultSet resultSet = null;
						if( sqlProc.SqlProcResultSets.Count < resultSetIx)
						{
							resultSet = new SqlProcResultSet("Set" + resultSetIx);
							sqlProc.SqlProcResultSets.Add(resultSet);
						}
						else
							resultSet = sqlProc.SqlProcResultSets[resultSetIx - 1];
						// read fields
						for( int colIx = 0; colIx < row.FieldCount; colIx++)
						{
							string columnName = row.GetName(colIx);
							string columnType = row.GetDataTypeName(colIx);
							resultSet.Columns.Add(new SqlProcColumn(columnName, colIx, columnType, resultSet.NullableColumns.Contains(columnName)));
						}
					});
				var nonConsumedParams = sqlProc.ParameterValues.Where(x => !x.Consumed).ToList();
				if( nonConsumedParams.Any())
					throw new Exception("Some parameters were defined but not used, stored proc may be different than expected, missing: " + string.Join(", ", nonConsumedParams.Select(p => p.ParameterName)));
				if( numberOfResultSetsRetrieved < sqlProc.SqlProcResultSets.Count)
					throw new Exception("Stored Proc " + sqlProc.ProcName + " expected to return at least " + sqlProc.SqlProcResultSets.Count + " result sets, got " + numberOfResultSetsRetrieved + " instead");
			}
			return this;
		}
		private void InspectResultSets(string sqlCommand, Action<int, SqlDataReader> readRow)
		{
			using(var sqlConnection = new SqlConnection(ConnectionString))
			{
				sqlConnection.Open();

				var sqlTransaction = sqlConnection.BeginTransaction();
				try
				{
					var sqlCmd = new SqlCommand(sqlCommand, sqlConnection, sqlTransaction);
					using( var sqlReader = sqlCmd.ExecuteReader())
					{
						int resultSetIx = 1;
						do
						{
							if(sqlReader.FieldCount > 0)
								readRow(resultSetIx++, sqlReader);
						} while( sqlReader.NextResult());
							
					}
				}
				finally
				{
					sqlTransaction.Rollback();
				}
			}
		}
		private void ExecuteQuery(string sqlCommand, Action<SqlDataReader> readRow)
		{
			using(var sqlConnection = new SqlConnection(ConnectionString))
			{
				sqlConnection.Open();

				var sqlTransaction = sqlConnection.BeginTransaction();
				try
				{
					var sqlCmd = new SqlCommand(sqlCommand, sqlConnection, sqlTransaction);
					using( var sqlReader = sqlCmd.ExecuteReader())
					{
						while(sqlReader.Read())
							readRow(sqlReader);
					}
				}
				finally
				{
					sqlTransaction.Rollback();
				}
			}
		}
	}

	public class SqlProc
	{
		public string ProcName { get; set; }
		public List<SqlProcResultSet> SqlProcResultSets { get; set; }

		public int ObjectId { get; set; }
		public List<SqlProcParameter> Parameters { get; set; }
		public List<SqlProcParameterValue> ParameterValues { get; set; }

		/* Helper properties */
		public string CSharpName
		{
			get
			{
				return string.Join("", ProcName.Split(new[] { "." }, StringSplitOptions.RemoveEmptyEntries)
					.Select(pn => pn.Substring(0,1).ToUpper() + pn.Substring(1)));
			}
		}
		public string CSharpNameUtilsClass { get { return CSharpName + "Utils"; } }
		public string CSharpResultClassName { get { return CSharpName + "Result"; } }
		public string CSharpRepositoryMethodName { get { return CSharpName; } }
		public string CSharpRepositoryAsyncMethodName { get { return CSharpName + "Async"; } }
		public string CSharpParametersList
		{
			get
			{
				return string.Join(", ", Parameters.Select(p => p.CSharpPropertyType + " " + p.CSharpNameLowercase));
			}
		}
		public string CSharpParametersCallMethod
		{
			get
			{
				return string.Join(", ", Parameters.Select(p => p.CSharpNameLowercase));
			}
		}
		public string SqlCallProc
		{
			get
			{
				return ProcName + " " + string.Join(", ", Parameters.Select(p => "@" + p.ParameterName + " = @" + p.ParameterName));
			}
		}
		public string GetParameterValue(string parameterName)
		{
			var paramValueConsumed = ParameterValues.FirstOrDefault(pv => pv.ParameterName == parameterName);
			if( paramValueConsumed != null)
			{
				paramValueConsumed.Consumed = true;
				return paramValueConsumed.ParameterValue;
			}
			return null;
		}

		public SqlProc(string procName)
		{
			ProcName = procName;
			SqlProcResultSets = new List<SqlProcResultSet>();
			ParameterValues = new List<SqlProcParameterValue>();
		}

		public SqlProc ResultSets(params string[] resultSetNames)
		{
			SqlProcResultSets.AddRange(resultSetNames.Select(rsn => new SqlProcResultSet(rsn)));
			return this;
		}

		public SqlProc SetParameterValue(string parameterName, string parameterValue)
		{
			ParameterValues.Add(new SqlProcParameterValue(parameterName, parameterValue));
			return this;
		}
	}
	public class SqlProcResultSet
	{
		public string ResultSetName { get; set; }
		public string ResultSetNamePlural
		{
			get 
			{
				if( ResultSetName.Last() >= '0' && ResultSetName.Last() <= '9')
					return ResultSetName;
				if( ResultSetName.EndsWith("s"))
					return ResultSetName + "es";
				if( ResultSetName.EndsWith("y"))
					return ResultSetName.Substring(0, ResultSetName.Length - 1) + "ies";
				return ResultSetName + "s";
			}
		}
		public List<SqlProcColumn> Columns { get; set; }
		public List<string> NullableColumns { get; set; }

		public string CSharpClassName { get { return ResultSetName == ResultSetNamePlural ? ResultSetName + "Container" : ResultSetName; } }
		public string CSharpCollectionName { get { return ResultSetNamePlural; } }

		public SqlProcResultSet(string resultSetName)
		{
			var m = Regex.Match(resultSetName, "(?<procname>[^;]+)(?:[;](?<nullablecolumn>[^;]*))*");
			NullableColumns = m.Groups["nullablecolumn"].Captures.Cast<Capture>().Select(c => c.Value).ToList();
			ResultSetName = m.Groups["procname"].Value;
			Columns = new List<SqlProcColumn>();
		}
	}
	public class SqlProcParameterValue
	{
		public string ParameterName { get; set; }
		public string ParameterValue { get; set; }
		public bool Consumed { get; set; }
		
		public SqlProcParameterValue(string parameterName, string parameterValue)
		{
			ParameterName = parameterName;
			ParameterValue = parameterValue;
		}
	}
	public class SqlProcParameter
	{
		public string ParameterName { get; set; }
		public string ParameterType { get; set; }
		public bool IsTvp { get; set; }
		public int TvpObjectId { get; set; }
		public List<SqlProcColumn> TvpColumns { get; set; }

		/* Helper properties */
		public string CSharpType
		{
			get
			{
				return IsTvp ? ParameterType : SqlDataTypesHelper.SqlTypeToCsharpType(ParameterType);
			}
		}
		public string CSharpPropertyType { get { return IsTvp ? "List<" + CSharpType + ">" : CSharpType; } }
		public string CSharpName { get { return ParameterName; } }
		public string CSharpNameLowercase { get { return SqlDataTypesHelper.StartWithLowercase(CSharpName); } }
		public string CSharpParametersList
		{
			get
			{
				return string.Join(", ", TvpColumns.Select(p => p.CSharpType + " " + p.CSharpNameLowercase));
			}
		}

		public SqlProcParameter(string parameterName, string parameterType, bool isTvp)
		{
			ParameterName = parameterName;
			ParameterType = parameterType;
			IsTvp = isTvp;
		}
	}
	public class SqlProcColumn
	{
		public string ColumnName { get; set; }
		public int ColumnIndex { get; set; }
		public string ColumnType { get; set; }
		public bool IsNullable { get; set; }

		/* Helper properties */
		public string CSharpType
		{
			get
			{
				return SqlDataTypesHelper.SqlTypeToCsharpType(ColumnType, IsNullable);
			}
		}
		public string CSharpTypeForDataSet
		{
			get
			{
				return SqlDataTypesHelper.SqlTypeToCsharpType(ColumnType, false);
			}
		}

		public string CSharpReaderGetterMethod(int colIx)
		{
			return SqlDataTypesHelper.SqlTypeToCSharpReaderGetterMethod(ColumnType, colIx, IsNullable);
		}

		public string CSharpName
		{
			get
			{
				return SqlDataTypesHelper.StartWithUppercase(ColumnName);
			}
		}

		public string CSharpNameLowercase
		{
			get
			{
				return SqlDataTypesHelper.StartWithLowercase(ColumnName);
			}
		}
		
		public SqlProcColumn(string columnName, int columnIndex, string columnType, bool isNullable = true)
		{
			ColumnName = columnName;
			ColumnIndex = columnIndex;
			ColumnType = columnType;
			IsNullable = isNullable;
		}
	}
	public static class SqlDataTypesHelper
	{
		public static string StartWithLowercase(string name)
		{
			if( name.Length < 2)
				return name.ToLower();
			return name.Substring(0, 1).ToLower() + name.Substring(1);
		}
		public static string StartWithUppercase(string name)
		{
			if( name.Length < 2)
				return name.ToUpper();
			return name.Substring(0, 1).ToUpper() + name.Substring(1);
		}
		public static string GetDefaultSqlValue(string sqlType)
		{
			switch(sqlType)
			{
				case "int":
				case "numeric":
				case "float":
				case "bit":
					return "0";
			}
			return "''";
		}
		public static string SqlTypeToCsharpType(string sqlType, bool nullable = false)
		{
			string suffix = nullable ? "?" : "";

			switch(sqlType.ToLower())
			{
				case "int":
				case "tinyint":
					return "int" + suffix;

				case "nvarchar":
				case "varchar":
				case "char":
					return "string";

				case "decimal":
				case "numeric":
					return "decimal" + suffix;

				case "float":
					return "double" + suffix;

				case "bit":
					return "bool" + suffix;

				default:
					return "unkown_type_" + sqlType;
			}
		}

		public static string SqlTypeToCSharpReaderGetterMethod(string sqlType, int colIx, bool nullable = false)
		{
			string csharpType = SqlTypeToCsharpType(sqlType, false);
			string methodName = "Unknown_Method_For_" + csharpType;
			switch(csharpType)
			{
				case "int":
					methodName = "GetInt32(" + colIx + (nullable ? "" : ", default(int)") + ")";
					break;
				case "string":
					methodName = "GetString(" + colIx + (nullable ? "" : ", default(string)") + ")";
					break;
				case "decimal":
					methodName = "GetDecimal(" + colIx + (nullable ? "" : ", default(decimal)") + ")";
					break;
				case "double":
					methodName = "GetDouble(" + colIx + (nullable ? "" : ", default(double)") + ")";
					break;
				case "bool":
					methodName = "GetBool(" + colIx + (nullable ? "" : ", default(bool)") + ")";
					break;
			}
			return methodName;
		}	
	}
#>