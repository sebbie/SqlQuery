<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ Assembly Name="System.Data" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data.SqlClient" #> 
<#@ import namespace="System.Text.RegularExpressions" #>
<#
    var sqlQuery = new SqlQuery();

	sqlQuery.ConnectionString = "Server=ServerName;Database=DatabaseName;Trusted_Connection=True;";
	sqlQuery.Namespace = "SqlQuery";

	sqlQuery.Add(new SqlProc("dbo.GetAllMakesAndModels").ResultSets("Make", "Model;EngineCapacityCc;IsManufactured"));
	sqlQuery.Add(new SqlProc("dbo.AddModels").SetParameterValue("makeId", "1"));

	sqlQuery.Add(new SqlRawQuery("GetAllTablesInDatabase", "SELECT TOP 10 * FROM sys.tables").ResultSets("Table"));

    sqlQuery.Add(new SqlEnum("dbo.CarTypes", "CarTypeName", "CarTypeId", "CarTypeEnum"));

	sqlQuery.ReadDatabase();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Last generated on <#= DateTime.Now #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Threading.Tasks;

namespace <#= sqlQuery.Namespace #>
{
	public static class Sql
	{
		private static SqlExecuteConnectionManagerDefault sqlConnectionManager = null;
		private static ISqlExecute _sqlExecute = null;
		private static IDbRepository _dbRepo = null;

		public static string ConnectionString { get; set; } = "<#= sqlQuery.ConnectionString.Replace("\\", "\\\\") #>";

		public static IDbRepository DbRepository
		{
			get
			{
				if( _dbRepo == null || sqlConnectionManager.ConnectionString != ConnectionString)
				{
					sqlConnectionManager = new SqlExecuteConnectionManagerDefault(ConnectionString);
					_sqlExecute = new SqlExecute(sqlConnectionManager);
					_dbRepo = new DbRepository(_sqlExecute);
				}
				return _dbRepo;
			}
		}
	}
	public class SqlExecuteConnectionManagerDefault : SqlExecuteConnectionManager
	{
		public string ConnectionString { get; set; }

		public SqlExecuteConnectionManagerDefault(string connectionString)
		{
			ConnectionString = connectionString;
		}
		public override string GetConnectionString()
		{
			return ConnectionString;
		}
	}
	public partial interface ISqlExecute
	{
		Task ExecuteSql(string sql, List<SqlExecuteParameter> parameters, Action<SqlExecutePopulateRowCtx> populateRow, SqlExecuteOptions sqlExecuteOptions);
	}
	public interface ISqlExecuteConnectionManager
	{
		string GetConnectionString();
		SqlConnection GetSqlConnection();
	}
	public abstract class SqlExecuteConnectionManager : ISqlExecuteConnectionManager
	{
		public abstract string GetConnectionString();

		public virtual SqlConnection GetSqlConnection()
		{
			return new SqlConnection(GetConnectionString());
		}
	}
	public class SqlErrorHandleDecision
    {
        public bool? TryAgain { get; set; }
        public int? CommandTimeout { get; set; }
        public object Tag { get; set; }

        public SqlErrorHandleDecision(bool? tryAgain, int? commandTimeout, object tag)
        {
            TryAgain = tryAgain;
            CommandTimeout = commandTimeout;
            Tag = tag;
        }
    }
    public class SqlExecuteOptions
    {
        public delegate SqlErrorHandleDecision OnErrorHandler(Exception ex, SqlErrorHandleDecision previousDecision, string sql, List<SqlExecuteParameter> parameters);

        public SqlExecuteOptions GlobalSqlExecuteOptions { get; set; }

        private int? _commandTimeout;
        public int? CommandTimeout { get => _commandTimeout ?? GlobalSqlExecuteOptions?.CommandTimeout; set => _commandTimeout = value; }
        
        private OnErrorHandler _onError;
        public OnErrorHandler OnError { get => _onError ?? GlobalSqlExecuteOptions?.OnError; set => _onError = value; }

		private bool? _rollbackTransaction;
        public bool? RollbackTransaction { get => _rollbackTransaction ?? GlobalSqlExecuteOptions?.RollbackTransaction; set => _rollbackTransaction = value; }

        public SqlExecuteOptions ApplyGlobalGlobalSqlExecuteOptions(SqlExecuteOptions sqlExecuteOptions)
        {
            GlobalSqlExecuteOptions = sqlExecuteOptions;
            return this;
        }

        public static OnErrorHandler HandleTimeouts(int retryTimeouts = 3)
        {
            return (Exception ex, SqlErrorHandleDecision previousDecision, string sql, List<SqlExecuteParameter> parameters) =>
            {
                bool isTimeout = (ex as SqlException)?.Number == -2;
                if (isTimeout)
                {
                    int attemptsMade = (int)(previousDecision.Tag ?? 1);
                    if (attemptsMade < retryTimeouts)
                        return new SqlErrorHandleDecision(true, (previousDecision?.CommandTimeout ?? 30) * attemptsMade, attemptsMade + 1);

                    return new SqlErrorHandleDecision(false, null, attemptsMade);
                }

                return null;
            };
        }
    }
	public class SqlExecuteParameter
	{
		public string ParameterName { get; set; }
		public object ParameterValue { get; set; }
		public SqlExecuteParameter(string parameterName, object parameterValue)
		{
			ParameterName = parameterName;
			ParameterValue = parameterValue;
		}
	}
	public class SqlExecutePopulateRowCtx
	{
		private SqlDataReader SqlDataReader { get; set; }
		public int ResultSetIx { get; set; }

		public SqlExecutePopulateRowCtx(SqlDataReader sqlDataReader)
		{
			SqlDataReader = sqlDataReader;
		}

		public byte? GetByte(int ix) => SqlDataReader.IsDBNull(ix) ? (byte?)null : SqlDataReader.GetByte(ix);
		public byte GetByte(int ix, byte defVal = 0) => GetByte(ix) ?? defVal;

		public short? GetInt16(int ix) => SqlDataReader.IsDBNull(ix) ? (short?)null : SqlDataReader.GetInt16(ix);
		public short GetInt16(int ix, short defVal = 0) => GetInt16(ix) ?? defVal;
		
		public int? GetInt32(int ix) => SqlDataReader.IsDBNull(ix) ? (int?)null : SqlDataReader.GetInt32(ix);
		public int GetInt32(int ix, int defVal = 0) => GetInt32(ix) ?? defVal;
		
		public long? GetInt64(int ix) => SqlDataReader.IsDBNull(ix) ? (long?)null : SqlDataReader.GetInt64(ix);
		public long GetInt64(int ix, long defVal = 0) => GetInt64(ix) ?? defVal;
		
		public string GetString(int ix, string defVal = null) => SqlDataReader.IsDBNull(ix) ? defVal : SqlDataReader.GetString(ix);

		public string GetXml(int ix, string defVal = null) => SqlDataReader.IsDBNull(ix) ? defVal : SqlDataReader.GetSqlXml(ix).Value;

		public byte[] GetBinary(int ix, byte[] defVal = null) => SqlDataReader.IsDBNull(ix) ? defVal : SqlDataReader.GetSqlBinary(ix).Value;

		public decimal? GetDecimal(int ix) => SqlDataReader.IsDBNull(ix) ? (decimal?)null : SqlDataReader.GetDecimal(ix);
		public decimal GetDecimal(int ix, decimal defVal = 0) => GetDecimal(ix) ?? defVal;

        public decimal? GetMoney(int ix) => SqlDataReader.IsDBNull(ix) ? (decimal?)null : SqlDataReader.GetSqlMoney(ix).Value;
		public decimal GetMoney(int ix, long defVal = 0) => GetMoney(ix) ?? defVal;

		public double? GetDouble(int ix) => SqlDataReader.IsDBNull(ix) ? (double?)null : SqlDataReader.GetDouble(ix);
		public double GetDouble(int ix, double defVal = 0) => GetDouble(ix) ?? defVal;

		public bool? GetBool(int ix) => SqlDataReader.IsDBNull(ix) ? (bool?)null : SqlDataReader.GetBoolean(ix);
		public bool GetBool(int ix, bool defVal = false) => GetBool(ix) ?? defVal;

        public DateTime? GetDateTime(int ix) => SqlDataReader.IsDBNull(ix) ? (DateTime?)null : SqlDataReader.GetDateTime(ix);
        public DateTime GetDateTime(int ix, DateTime defVal) => GetDateTime(ix) ?? defVal;

		public Guid? GetGuid(int ix) => SqlDataReader.IsDBNull(ix) ? (Guid?)null : SqlDataReader.GetGuid(ix);
        public Guid GetGuid(int ix, Guid defVal) => GetGuid(ix) ?? defVal;
	}
	public class SqlExecute : ISqlExecute
	{
		public ISqlExecuteConnectionManager SqlExecuteConnectionManager { get; set; }
		public SqlExecute(ISqlExecuteConnectionManager sqlExecuteConnectionManager)
		{
			SqlExecuteConnectionManager = sqlExecuteConnectionManager;
		}

		public async Task ExecuteSql(string sql, List<SqlExecuteParameter> parameters, Action<SqlExecutePopulateRowCtx> populateRow, SqlExecuteOptions sqlExecuteOptions)
		{
			SqlTransaction sqlTransaction = null;
            bool keepExecuting = true;
            int maximumExecCount = 99;
            int commandTimeout = sqlExecuteOptions?.CommandTimeout ?? 30;
			SqlErrorHandleDecision errorHandleDecision = new SqlErrorHandleDecision(true, commandTimeout, null);

            while (keepExecuting && maximumExecCount-- > 0)
			{
				try
				{
					using (var sqlConnection = SqlExecuteConnectionManager.GetSqlConnection())
					{
						if( sqlConnection.State != ConnectionState.Open)
							sqlConnection.Open();
						sqlTransaction = sqlConnection.BeginTransaction();

						var sqlCmd = new SqlCommand(sql, sqlConnection, sqlTransaction);
						sqlCmd.CommandTimeout = commandTimeout;
						foreach (var parameter in parameters)
						{
							var sqlParam = new SqlParameter(parameter.ParameterName, parameter.ParameterValue);
							if (parameter.ParameterValue is DataTable)
							{
								sqlParam.TypeName = ((DataTable)parameter.ParameterValue).TableName;
								sqlParam.SqlDbType = SqlDbType.Structured;
							}

							sqlCmd.Parameters.Add(sqlParam);
						}

						var sqlDataReaderAsync = sqlCmd.ExecuteReaderAsync();
						await sqlDataReaderAsync;
						if (sqlDataReaderAsync.IsFaulted)
							throw sqlDataReaderAsync.Exception;

						// reader ready
						var sqlDataReader = sqlDataReaderAsync.Result;
						SqlExecutePopulateRowCtx populateRowCtx = new SqlExecutePopulateRowCtx(sqlDataReader);
						bool readNextResultSet = false;
						do
						{
							while (true)
							{
								var readAsync = sqlDataReader.ReadAsync();
								await readAsync;
								if (readAsync.IsFaulted)
									throw readAsync.Exception;

								if (!readAsync.Result)
									break;

								populateRow(populateRowCtx);
							}

							// advance to next result set
							var nextResultAsync = sqlDataReader.NextResultAsync();
							await nextResultAsync;
							if (nextResultAsync.IsFaulted)
								throw nextResultAsync.Exception;
							readNextResultSet = nextResultAsync.Result;

							populateRowCtx.ResultSetIx++;

						} while (readNextResultSet);
						sqlDataReader.Close();
						if (sqlTransaction != null)
                        {
                            if( sqlExecuteOptions?.RollbackTransaction == true)
                                sqlTransaction.Rollback();
                            else
                                sqlTransaction.Commit();
                        }
						sqlTransaction = null;
					}
					keepExecuting = false;
				}
				catch(Exception ex)
				{
					bool errorHandled = false;
                    if (sqlExecuteOptions?.OnError != null)
					{
                        errorHandleDecision = sqlExecuteOptions.OnError(ex, errorHandleDecision, sql, parameters);
                        if (errorHandleDecision != null)
                        {
                            keepExecuting = errorHandleDecision.TryAgain ?? keepExecuting;
                            commandTimeout = errorHandleDecision.CommandTimeout ?? commandTimeout;
                            errorHandled = true;
                        }
                    }

					try
					{
						sqlTransaction?.Rollback();
					}
					catch( Exception exceptionToIgnore) { }

                    if (!errorHandled)
						throw new Exception($"Sql '{sql}' failed: {ex.Message}", ex);
				}
			}
		}
	}
<#
        foreach(var sqlEnum in sqlQuery.SqlEnums)
        {
#>
    public enum <#= sqlEnum.CSharpName #>
    {
<#
        foreach(var sqlEnumEntry in sqlEnum.Entries)
        {
#>
        <#= sqlEnumEntry.CSharpName #> = <#= sqlEnumEntry.Value #><#= sqlEnum.Entries.Last() == sqlEnumEntry ? "" : "," #>
<#
        }
#>
    }
<#
        }
#>
<#
		// utility class
		foreach(var sqlProc in sqlQuery.SqlProcs)
		{
#>
	public static class <#= sqlProc.CSharpNameUtilsClass #>
	{
		public const string StoredProcedureName = "<#= sqlProc.SqlCallProc #>";
<#		string sqlToExecute = sqlProc.QueryType == SqlProc.QueryTypeEnum.RawQuery ? ((SqlRawQuery)sqlProc).RawSql : sqlProc.SqlCallProc; #>
		public const string SqlToExecute = "<#= sqlToExecute #>";
		

		public static async Task<<#= sqlProc.CSharpResultClassName #>> Query(ISqlExecute sqlExecute<#= sqlProc.Parameters.Any() ? ", " : "" #><#= sqlProc.CSharpParametersList #>, SqlExecuteOptions sqlExecuteOptions)
		{
			var parameters = new List<SqlExecuteParameter>
			{
<#
		foreach(SqlProcParameter param in sqlProc.Parameters)
		{
#>				new SqlExecuteParameter("<#= param.ParameterName #>", <#= param.IsTvp ? (param.CSharpType + ".ToDataTable(" + param.ParameterName + ")") : (param.ParameterName + " ?? (object)DBNull.Value") #>),
<#
		}
#>
			};

<#
		int paramIx = 0;
		foreach(SqlProcResultSet resultSet in sqlProc.SqlProcResultSets)
		{
#>		    List<<#= sqlProc.CSharpResultClassName #>.<#= resultSet.CSharpClassName #>> result<#= paramIx++ #> = new List<<#= sqlProc.CSharpResultClassName #>.<#= resultSet.CSharpClassName #>>();
<#
		}
#>

			var executeSqlStatus = sqlExecute.ExecuteSql(StoredProcedureName, parameters, sqlExecutePopulateRowCtx =>
			{
<#
				if(sqlProc.SqlProcResultSets.Any())
				{
#>
				switch (sqlExecutePopulateRowCtx.ResultSetIx)
				{
<#
		for(int i = 0; i < sqlProc.SqlProcResultSets.Count; i++)
		{
#>
					case <#= i #>: result<#= i #>.Add(Populate<#= i #>(CreateNew<#= i #>(), sqlExecutePopulateRowCtx)); break;
<#
		}
#>
				}
<#
				}
#>
			}, sqlExecuteOptions);
			await executeSqlStatus;
			if (executeSqlStatus.IsFaulted)
				throw executeSqlStatus.Exception;
			return new <#= sqlProc.CSharpResultClassName #>
			{
<#
		for(int i = 0; i < sqlProc.SqlProcResultSets.Count; i++)
		{
#>				<#= sqlProc.SqlProcResultSets[i].CSharpCollectionName #> = result<#= i #>,
<#		}
#>
			};
		}
<#
		for(int i = 0; i < sqlProc.SqlProcResultSets.Count; i++)
		{
			var resultSet = sqlProc.SqlProcResultSets[i];
#>
		public static <#= sqlProc.CSharpResultClassName #>.<#= resultSet.CSharpClassName #> CreateNew<#= i #>() => new <#= sqlProc.CSharpResultClassName #>.<#= resultSet.CSharpClassName #>();
<#		}

		for(int i = 0; i < sqlProc.SqlProcResultSets.Count; i++)
		{
			var resultSet = sqlProc.SqlProcResultSets[i];
#>

		public static <#= sqlProc.CSharpResultClassName #>.<#= resultSet.CSharpClassName #> Populate<#= i #>(<#= sqlProc.CSharpResultClassName #>.<#= resultSet.CSharpClassName #> dst, SqlExecutePopulateRowCtx src)
		{
<#
			for(int colIx = 0; colIx < resultSet.Columns.Count; colIx++)
			{
				SqlProcColumn column = resultSet.Columns[colIx];
#>
			dst.<#= column.CSharpName #> = src.<#= column.CSharpReaderGetterMethod(colIx) #>;
<#
			}
#>
			return dst;
		}
<#
		}
#>
	}
<#
		}
#>

<#
	var tvpParameters = sqlQuery.SqlProcs.SelectMany(proc => proc.Parameters.Where(prm => prm.IsTvp)).ToList();
	List<string> alreadyGenerated = new List<string>();
	foreach(SqlProcParameter sqlProcParam in tvpParameters)
	{
		if(alreadyGenerated.Contains(sqlProcParam.ParameterType))
			continue;
		alreadyGenerated.Add(sqlProcParam.ParameterType);
#>
	public partial class <#= sqlProcParam.CSharpType #>
	{
		public static string DbName { get; set; } = "<#= sqlProcParam.TvpSqlTypeName #>";

<#		foreach(SqlProcColumn column in sqlProcParam.TvpColumns)
		{
#>		public <#= column.CSharpType #> <#= column.CSharpName #> { get; set; }
<#		}
#>

		public <#= sqlProcParam.CSharpType #>(<#= sqlProcParam.CSharpParametersList #>)
		{
<#		foreach(SqlProcColumn column in sqlProcParam.TvpColumns)
		{
#>			this.<#= column.CSharpName #> = <#= column.CSharpNameLowercase #>;
<#		}
#>		}

		public static DataTable ToDataTable(List<<#= sqlProcParam.CSharpType #>> src)
		{
			DataTable dst = new DataTable(DbName);
<#		foreach(SqlProcColumn column in sqlProcParam.TvpColumns)
		{
#>			dst.Columns.Add("<#= column.ColumnName #>", typeof(<#= column.CSharpTypeForDataSet #>));
<#		}
#>
			foreach (<#= sqlProcParam.CSharpType #> s in src)
				dst.Rows.Add(<#= string.Join(", ", sqlProcParam.TvpColumns.Select(column => "s." + column.CSharpName)) #>);
			return dst;
		}
	}
<#
	}

	foreach(var sqlProc in sqlQuery.SqlProcs)
	{
#>
	public partial class <#= sqlProc.CSharpResultClassName #>
	{
<#
		foreach(SqlProcResultSet resultSet in sqlProc.SqlProcResultSets)
		{
#>
		public partial class <#= resultSet.CSharpClassName #>
		{
<#
			foreach(SqlProcColumn column in resultSet.Columns)
			{
#>
			public <#= column.CSharpType #> <#= column.CSharpName #> { get; set; }
<#
			}
#>		}
<#
		}
		foreach(SqlProcResultSet resultSet in sqlProc.SqlProcResultSets)
		{
#>		public List<<#= resultSet.CSharpClassName #>> <#= resultSet.CSharpCollectionName #> { get; set; }
<#
		}
#>
	}
<#	} #>
	public partial interface IDbRepository
	{
<#		foreach(var sqlProc in sqlQuery.SqlProcs)
		{
#>
		<#= sqlProc.CSharpResultClassName #> <#= sqlProc.CSharpRepositoryMethodName #>(<#= sqlProc.CSharpParametersList #><#= string.IsNullOrWhiteSpace(sqlProc.CSharpParametersList) ? "" : ", " #>SqlExecuteOptions sqlExecuteOptions = null);
		Task<<#= sqlProc.CSharpResultClassName #>> <#= sqlProc.CSharpRepositoryAsyncMethodName #>(<#= sqlProc.CSharpParametersList #><#= string.IsNullOrWhiteSpace(sqlProc.CSharpParametersList) ? "" : ", " #>SqlExecuteOptions sqlExecuteOptions = null);

<#
		}
#>
	}
	public class DbRepository : IDbRepository
	{
		//public static SqlExecuteOptions DefaultSqlExecuteOptions = null;
		public static SqlExecuteOptions GlobalSqlExecuteOptions = null;
		public virtual SqlExecuteOptions DefaultSqlExecuteOptions { get => GlobalSqlExecuteOptions; }

		public ISqlExecute _sqlExecute;
		public DbRepository(ISqlExecute sqlExecute)
		{
			_sqlExecute = sqlExecute;
		}

<#		foreach(var sqlProc in sqlQuery.SqlProcs)
		{
#>
		public <#= sqlProc.CSharpResultClassName #> <#= sqlProc.CSharpRepositoryMethodName #>(<#= sqlProc.CSharpParametersList #><#= string.IsNullOrWhiteSpace(sqlProc.CSharpParametersList) ? "" : ", " #>SqlExecuteOptions sqlExecuteOptions = null) =>
			<#= sqlProc.CSharpNameUtilsClass #>.Query(_sqlExecute<#= sqlProc.Parameters.Any() ? ", " : "" #><#= sqlProc.CSharpParametersCallMethod #>, sqlExecuteOptions?.ApplyGlobalGlobalSqlExecuteOptions(DefaultSqlExecuteOptions) ?? DefaultSqlExecuteOptions).Result;
		public Task<<#= sqlProc.CSharpResultClassName #>> <#= sqlProc.CSharpRepositoryAsyncMethodName #>(<#= sqlProc.CSharpParametersList #><#= string.IsNullOrWhiteSpace(sqlProc.CSharpParametersList) ? "" : ", " #>SqlExecuteOptions sqlExecuteOptions = null) =>
			<#= sqlProc.CSharpNameUtilsClass #>.Query(_sqlExecute<#= sqlProc.Parameters.Any() ? ", " : "" #><#= sqlProc.CSharpParametersCallMethod #>, sqlExecuteOptions?.ApplyGlobalGlobalSqlExecuteOptions(DefaultSqlExecuteOptions) ?? DefaultSqlExecuteOptions);

<#		}
#>
	}
}

<#+
	public class SqlQuery
	{
		public string ConnectionString {get; set;}
        public List<SqlProc> SqlProcs {get; set;}
		public List<SqlEnum> SqlEnums {get; set;}
		public string Namespace { get; set; }

		public SqlQuery()
		{
			SqlProcs = new List<SqlProc>();
            SqlEnums = new List<SqlEnum>();
		}

		public SqlQuery(string connectionString, string @namespace)
			: this()
		{
			ConnectionString = connectionString;
			Namespace = @namespace;
		}

		public SqlQuery Add(SqlProc sqlProc)
		{
			SqlProcs.Add(sqlProc);
			return this;
		}

        public SqlQuery Add(SqlEnum sqlEnum)
        {
            SqlEnums.Add(sqlEnum);
            return this;
        }

		public SqlQuery ReadDatabase()
		{
			foreach(var sqlProc in SqlProcs)
			{
				// read proc details
				ExecuteQuery("SELECT p.name ProcName, s.name SchemaName, p.object_id ProcObjectId FROM sys.procedures p join sys.schemas s on s.schema_id = p.schema_id WHERE s.name + '.' + p.name = '" + sqlProc.ProcName +  "'", row =>
					{
						sqlProc.ObjectId = row.GetInt32(2);
					});
				// read parameters list
				sqlProc.Parameters = new List<SqlProcParameter>();
				if( sqlProc.QueryType != SqlProc.QueryTypeEnum.RawQuery)
				{
					ExecuteQuery("select pa.name ParamName, pa.parameter_id ParameterOrder, sch.name SchemaName, ty.name ParamType, CAST(CASE WHEN ty.system_type_id <> ty.user_type_id THEN 1 ELSE 0 END AS BIT) IsTvp from sys.parameters pa join sys.types ty on ty.user_type_id = pa.user_type_id and ty.system_type_id = pa.system_type_id JOIN sys.schemas sch ON sch.schema_id = ty.schema_id where object_id = " + sqlProc.ObjectId + " order by parameter_id", row =>
						{
							sqlProc.Parameters.Add(new SqlProcParameter(row.GetString(0).Substring(1), row.GetString(2), row.GetString(3), row.GetBoolean(4)));
						});
					// read tvp definitions
					foreach(var param in sqlProc.Parameters.Where(p => p.IsTvp))
					{
						// tvp object id
						ExecuteQuery("select tt.type_table_object_id from sys.table_types tt where tt.name = '" + param.ParameterType + "'", row =>
							{
								param.TvpObjectId = row.GetInt32(0);
							});
						// tvp columns
						param.TvpColumns = new List<SqlProcColumn>();
						ExecuteQuery("select c.name TvpColumnName, c.column_id ColumnIx, ty.name TypeName, c.is_nullable IsNullable from sys.columns c join sys.types ty on ty.user_type_id = c.user_type_id and ty.system_type_id = c.system_type_id where c.object_id = " + param.TvpObjectId, row =>
							{
								param.TvpColumns.Add(new SqlProcColumn(
									row.GetString(0),
									row.GetInt32(1),
									row.GetString(2),
									row.GetBoolean(3)));
							});
					}
				}
				// result sets
				var nonTvpParams = sqlProc.Parameters.Where(p => !p.IsTvp).ToList();
				int numberOfResultSetsRetrieved = 0;
				string sqlToExecute = sqlProc.QueryType == SqlProc.QueryTypeEnum.RawQuery ?
					((SqlRawQuery)sqlProc).RawSql :
					$"EXEC {sqlProc.ProcName} " + string.Join(", ", nonTvpParams.Select(p => "@" + p.ParameterName + "=" + (sqlProc.GetParameterValue(p.ParameterName) ?? SqlDataTypesHelper.GetDefaultSqlValue(p.ParameterType))));
				InspectResultSets(sqlToExecute, 
                    (resultSetIx, row) =>
					{
						if( resultSetIx > numberOfResultSetsRetrieved)
							numberOfResultSetsRetrieved = resultSetIx;
						SqlProcResultSet resultSet = null;
						if( sqlProc.SqlProcResultSets.Count < resultSetIx)
						{
							resultSet = new SqlProcResultSet("Set" + resultSetIx);
							sqlProc.SqlProcResultSets.Add(resultSet);
						}
						else
							resultSet = sqlProc.SqlProcResultSets[resultSetIx - 1];
						// read fields
						for( int colIx = 0; colIx < row.FieldCount; colIx++)
						{
							string columnName = row.GetName(colIx);
							string columnType = row.GetDataTypeName(colIx);
							resultSet.Columns.Add(new SqlProcColumn(columnName, colIx, columnType, resultSet.NullableColumns.Contains(columnName)));
						}
					});
				var nonConsumedParams = sqlProc.ParameterValues.Where(x => !x.Consumed).ToList();
				if( nonConsumedParams.Any())
					throw new Exception("Some parameters were defined but not used, stored proc may be different than expected, missing: " + string.Join(", ", nonConsumedParams.Select(p => p.ParameterName)));
				if( numberOfResultSetsRetrieved < sqlProc.SqlProcResultSets.Count)
					throw new Exception("Stored Proc " + sqlProc.ProcName + " expected to return at least " + sqlProc.SqlProcResultSets.Count + " result sets, got " + numberOfResultSetsRetrieved + " instead");
			}

            foreach(var sqlEnum in SqlEnums)
            {
                InspectResultSets("SELECT t." + sqlEnum.ColumnText + ", t." + sqlEnum.ColumnValue + " FROM " + sqlEnum.TableName + " t",
                    (resultSetIx, row) =>
                    {
                        while(row.Read())
                        {
                            sqlEnum.AddEntry(row.GetString(0), row.GetInt32(1));
                        }
                    });
            }

			return this;
		}
		private void InspectResultSets(string sqlCommand, Action<int, SqlDataReader> readRow)
		{
			using(var sqlConnection = new SqlConnection(ConnectionString))
			{
				sqlConnection.Open();

				var sqlTransaction = sqlConnection.BeginTransaction();
				try
				{
					var sqlCmd = new SqlCommand(sqlCommand, sqlConnection, sqlTransaction);
					using( var sqlReader = sqlCmd.ExecuteReader())
					{
						int resultSetIx = 1;
						do
						{
							if(sqlReader.FieldCount > 0)
								readRow(resultSetIx++, sqlReader);
						} while( sqlReader.NextResult());
							
					}
				}
                catch(Exception ex)
                {
                    sqlTransaction?.Rollback();
                    throw new Exception($"SqlCommand='{sqlCommand}' ConnectionString='{ConnectionString}'", ex);
                }
			}
		}
		private void ExecuteQuery(string sqlCommand, Action<SqlDataReader> readRow)
		{
			using(var sqlConnection = new SqlConnection(ConnectionString))
			{
				sqlConnection.Open();

				var sqlTransaction = sqlConnection.BeginTransaction();
				try
				{
					var sqlCmd = new SqlCommand(sqlCommand, sqlConnection, sqlTransaction);
					using( var sqlReader = sqlCmd.ExecuteReader())
					{
						while(sqlReader.Read())
							readRow(sqlReader);
					}
				}
				finally
				{
					sqlTransaction.Rollback();
				}
			}
		}
	}

	public class SqlRawQuery : SqlProc
	{
		public override QueryTypeEnum QueryType {get; set;} = QueryTypeEnum.RawQuery;

		public string RawSql { get; set; }
		
		public SqlRawQuery(string procName, string rawSql)
			: base(procName)
		{
			RawSql = rawSql;
		}
	}

	public class SqlProc
	{
		public enum QueryTypeEnum
		{
			StoredProcedure,
			RawQuery
		}
		public virtual QueryTypeEnum QueryType {get; set;} = QueryTypeEnum.StoredProcedure;

		public string ProcName { get; set; }
		public List<SqlProcResultSet> SqlProcResultSets { get; set; }

		public int ObjectId { get; set; }
		public List<SqlProcParameter> Parameters { get; set; }
		public List<SqlProcParameterValue> ParameterValues { get; set; }

		/* Helper properties */
		public string CSharpName
		{
			get
			{
				return string.Join("", ProcName.Split(new[] { "." }, StringSplitOptions.RemoveEmptyEntries)
					.Select(pn => pn.Substring(0,1).ToUpper() + pn.Substring(1)));
			}
		}
		public string CSharpNameUtilsClass { get { return CSharpName + "Utils"; } }
		public string CSharpResultClassName { get { return CSharpName + "Result"; } }
		public string CSharpRepositoryMethodName { get { return CSharpName; } }
		public string CSharpRepositoryAsyncMethodName { get { return CSharpName + "Async"; } }
		public string CSharpParametersList
		{
			get
			{
				return string.Join(", ", Parameters.Select(p => p.CSharpPropertyType + " " + p.CSharpNameLowercase));
			}
		}
		public string CSharpParametersCallMethod
		{
			get
			{
				return string.Join(", ", Parameters.Select(p => p.CSharpNameLowercase));
			}
		}
		public string SqlCallProc
		{
			get
			{
				return ProcName + (Parameters.Any() ? " " : "") + string.Join(", ", Parameters.Select(p => "@" + p.ParameterName + " = @" + p.ParameterName));
			}
		}
		public string GetParameterValue(string parameterName)
		{
			var paramValueConsumed = ParameterValues.FirstOrDefault(pv => pv.ParameterName == parameterName);
			if( paramValueConsumed != null)
			{
				paramValueConsumed.Consumed = true;
				return paramValueConsumed.ParameterValue;
			}
			return null;
		}

		public SqlProc(string procName)
		{
			ProcName = procName;
			SqlProcResultSets = new List<SqlProcResultSet>();
			ParameterValues = new List<SqlProcParameterValue>();
		}

		public SqlProc ResultSets(params string[] resultSetNames)
		{
			SqlProcResultSets.AddRange(resultSetNames.Select(rsn => new SqlProcResultSet(rsn)));
			return this;
		}

		public SqlProc SetParameterValue(string parameterName, string parameterValue)
		{
			ParameterValues.Add(new SqlProcParameterValue(parameterName, parameterValue));
			return this;
		}
	}
	public class SqlProcResultSet
	{
		public string ResultSetName { get; set; }
		public string ResultSetNamePlural
		{
			get 
			{
				if( ResultSetName.Last() >= '0' && ResultSetName.Last() <= '9')
					return ResultSetName;
				if( ResultSetName.EndsWith("s"))
					return ResultSetName + "es";
				if( ResultSetName.EndsWith("y"))
					return ResultSetName.Substring(0, ResultSetName.Length - 1) + "ies";
				return ResultSetName + "s";
			}
		}
		public List<SqlProcColumn> Columns { get; set; }
		public List<string> NullableColumns { get; set; }

		public string CSharpClassName { get { return ResultSetName == ResultSetNamePlural ? ResultSetName + "Container" : ResultSetName; } }
		public string CSharpCollectionName { get { return ResultSetNamePlural; } }

		public SqlProcResultSet(string resultSetName)
		{
			var m = Regex.Match(resultSetName, "(?<procname>[^;]+)(?:[;](?<nullablecolumn>[^;]*))*");
			NullableColumns = m.Groups["nullablecolumn"].Captures.Cast<Capture>().Select(c => c.Value).ToList();
			ResultSetName = m.Groups["procname"].Value;
			Columns = new List<SqlProcColumn>();
		}
	}
	public class SqlProcParameterValue
	{
		public string ParameterName { get; set; }
		public string ParameterValue { get; set; }
		public bool Consumed { get; set; }
		
		public SqlProcParameterValue(string parameterName, string parameterValue)
		{
			ParameterName = parameterName;
			ParameterValue = parameterValue;
		}
	}
	public class SqlProcParameter
	{
		public string ParameterName { get; set; }
		public string ParameterTypeSchema { get; set; }
		public string ParameterType { get; set; }
		public bool IsTvp { get; set; }
		public int TvpObjectId { get; set; }
		public List<SqlProcColumn> TvpColumns { get; set; }
        private bool TvpIsDboSchema => string.Equals(ParameterTypeSchema, "dbo", StringComparison.InvariantCultureIgnoreCase);
        public string TvpSqlTypeName => TvpIsDboSchema ? ParameterType : $"{ParameterTypeSchema}.{ParameterType}";

		/* Helper properties */
		public string CSharpType
		{
			get
			{
				return IsTvp ? $"{(TvpIsDboSchema ? "" : (ParameterTypeSchema[0].ToString().ToUpper() + ParameterTypeSchema.Substring(1)))}{ParameterType}" : SqlDataTypesHelper.SqlTypeToCsharpType(ParameterType, true);
			}
		}
		public string CSharpPropertyType { get { return IsTvp ? "List<" + CSharpType + ">" : CSharpType; } }
		public string CSharpName { get { return ParameterName; } }
		public string CSharpNameLowercase { get { return SqlDataTypesHelper.StartWithLowercase(CSharpName); } }
		public string CSharpParametersList
		{
			get
			{
				return string.Join(", ", TvpColumns.Select(p => p.CSharpType + " " + p.CSharpNameLowercase));
			}
		}

		public SqlProcParameter(string parameterName, string parameterTypeSchema, string parameterType, bool isTvp)
		{
			ParameterName = parameterName;
		    ParameterTypeSchema = parameterTypeSchema;
			ParameterType = parameterType;
			IsTvp = isTvp;
		}
	}
	public class SqlProcColumn
	{
		public string ColumnName { get; set; }
		public int ColumnIndex { get; set; }
		public string ColumnType { get; set; }
		public bool IsNullable { get; set; }

		/* Helper properties */
		public string CSharpType
		{
			get
			{
				return SqlDataTypesHelper.SqlTypeToCsharpType(ColumnType, IsNullable);
			}
		}
		public string CSharpTypeForDataSet
		{
			get
			{
				return SqlDataTypesHelper.SqlTypeToCsharpType(ColumnType, false);
			}
		}

		public string CSharpReaderGetterMethod(int colIx)
		{
			return SqlDataTypesHelper.SqlTypeToCSharpReaderGetterMethod(ColumnType, colIx, IsNullable);
		}

		public string CSharpName
		{
			get
			{
				return SqlDataTypesHelper.StartWithUppercase(ColumnName);
			}
		}

		public string CSharpNameLowercase
		{
			get
			{
				return SqlDataTypesHelper.StartWithLowercase(ColumnName);
			}
		}
		
		public SqlProcColumn(string columnName, int columnIndex, string columnType, bool isNullable = true)
		{
			ColumnName = columnName;
			ColumnIndex = columnIndex;
    		ColumnType = columnType;
			IsNullable = isNullable;
		}
	}
    public class SqlEnum
    {
        public string TableName { get; set; }
        public string ColumnText { get; set; }
        public string ColumnValue { get; set; }
        public string EnumCSharpName { get; set; }

        /* Helper properties */
        public string CSharpName
        {
            get
            {
				if(!string.IsNullOrWhiteSpace(EnumCSharpName))
					return EnumCSharpName;
                return string.Join("", TableName.Split(new[] { "." }, StringSplitOptions.RemoveEmptyEntries)
                    .Skip(1)
                    .Select(pn => pn.Substring(0,1).ToUpper() + pn.Substring(1)));
            }
        }

        public List<SqlEnumEntry> Entries { get; set; }

        public SqlEnum(string tableName, string columnText, string columnValue, string enumCSharpName = null)
        {
            TableName = tableName;
            ColumnText = columnText;
            ColumnValue = columnValue;
			EnumCSharpName = enumCSharpName;
            Entries = new List<SqlEnumEntry>();
        }

        public SqlEnum AddEntry(string text, int val)
        {
            Entries.Add(new SqlEnumEntry(text, val));
            return this;
        }

    }
    public class SqlEnumEntry
    {
        public string Text { get; set; }
        public int Value { get; set; }

        /* Helper properties */
        public string CSharpName
        {
            get
            {
                return string.Join("", Text.Split(new[] { ".", " " }, StringSplitOptions.RemoveEmptyEntries)
                    .Select(pn => pn.Substring(0,1).ToUpper() + pn.Substring(1)));
            }
        }

        public SqlEnumEntry(string text, int val)
        {
            this.Text = text;
            this.Value = val;
        }
    }
	public static class SqlDataTypesHelper
	{
		public static string StartWithLowercase(string name)
		{
			if( name.Length < 2)
				return name.ToLower();
			return name.Substring(0, 1).ToLower() + name.Substring(1);
		}
		public static string StartWithUppercase(string name)
		{
			if( name.Length < 2)
				return name.ToUpper();
			return name.Substring(0, 1).ToUpper() + name.Substring(1);
		}
		public static string GetDefaultSqlValue(string sqlType)
		{
			switch(sqlType)
			{
				case "int":
				case "numeric":
				case "float":
				case "bit":
				case "bigint":
				case "decimal":
					return "0";
				
				case "uniqueidentifier":
					return "'00000000-0000-0000-0000-000000000000'";
			}
			return "''";
		}
		public static string SqlTypeToCsharpType(string sqlType, bool nullable = false)
		{
			string suffix = nullable ? "?" : "";

			switch(sqlType.ToLower())
			{
				case "tinyint":
					return "byte" + suffix;
				
				case "smallint":
					return "short" + suffix;

				case "int":
					return "int" + suffix;

				case "bigint":
					return "long" + suffix;

				case "money":
					return "decimal" + suffix;

				case "nvarchar":
				case "varchar":
				case "char":
					return "string";

				case "decimal":
				case "numeric":
					return "decimal" + suffix;

				case "float":
					return "double" + suffix;

				case "bit":
					return "bool" + suffix;

                case "datetime":
                case "date":
                    return "DateTime" + suffix;

                case "varbinary":
                    return "byte[]";

				case "xml":
					return "string";

				case "uniqueidentifier":
					return "Guid" + suffix;

				default:
					return "unknown_type_" + sqlType;
			}
		}

		public static string SqlTypeToCSharpReaderGetterMethod(string sqlType, int colIx, bool nullable = false)
		{
			string csharpType = SqlTypeToCsharpType(sqlType, false);
			string methodName = "Unknown_Method_For_" + csharpType;
			switch(csharpType)
			{
				case "byte":
					methodName = "GetByte(" + colIx + (nullable ? "" : ", default(byte)") + ")";
					break;
				case "short":
					methodName = "GetInt16(" + colIx + (nullable ? "" : ", default(short)") + ")";
					break;
				case "int":
					methodName = "GetInt32(" + colIx + (nullable ? "" : ", default(int)") + ")";
					break;
				case "long":
					methodName = "GetInt64(" + colIx + (nullable ? "" : ", default(long)") + ")";
					break;
				case "string":
					methodName = "GetString(" + colIx + (nullable ? "" : ", default(string)") + ")";
					break;
				case "decimal":
					methodName = "GetDecimal(" + colIx + (nullable ? "" : ", default(decimal)") + ")";
					break;
				case "money":
					methodName = "GetMoney(" + colIx + (nullable ? "" : ", default(decimal)") + ")";
					break;
				case "double":
					methodName = "GetDouble(" + colIx + (nullable ? "" : ", default(double)") + ")";
					break;
				case "bool":
					methodName = "GetBool(" + colIx + (nullable ? "" : ", default(bool)") + ")";
					break;
                case "DateTime":
                    methodName = "GetDateTime(" + colIx + (nullable ? "" : ", default(DateTime)") + ")";
                    break;
                case "Xml":
                    methodName = "GetXml(" + colIx + (nullable ? "" : ", default(string)") + ")";
                    break;
                case "byte[]":
                    methodName = "GetBinary(" + colIx + (nullable ? "" : ", default(byte[])") + ")";
                    break;
                case "xml":
                    methodName = "GetXml(" + colIx + (nullable ? "" : ", default(string)") + ")";
                    break;
				case "Guid":
                    methodName = "GetGuid(" + colIx + (nullable ? "" : ", default(Guid)") + ")";
                    break;
			}
			return methodName;
		}	
	}
#>